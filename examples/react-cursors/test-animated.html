<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SyncKit Cursors - Smooth Animation Test</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }

    .header {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    h1 {
      font-size: 24px;
      margin-bottom: 10px;
    }

    .status {
      font-family: monospace;
      background: #f0f0f0;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
    }

    .status-ok { color: #22c55e; }
    .toggle-container {
      margin: 15px 0;
      padding: 15px;
      background: #eff6ff;
      border-radius: 6px;
    }

    .toggle-label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 500;
    }

    .workspace {
      background: white;
      min-height: 500px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 40px;
    }

    .instructions {
      background: #eff6ff;
      border: 1px solid #bfdbfe;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
    }

    .instructions h3 {
      color: #1e40af;
      margin-bottom: 10px;
    }

    .instructions ol {
      margin-left: 20px;
    }

    .instructions li {
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    /**
     * Spring animation class (simplified from SDK)
     */
    class SpringAnimation {
      constructor(config = {}) {
        this.config = {
          damping: 45,
          stiffness: 400,
          mass: 1,
          restDelta: 0.001,
          ...config
        };

        this.spring = {
          x: { position: 0, velocity: 0, target: 0 },
          y: { position: 0, velocity: 0, target: 0 }
        };

        this.rafId = null;
        this.lastTime = 0;
        this.onUpdate = null;
      }

      setTarget(target) {
        this.spring.x.target = target.x;
        this.spring.y.target = target.y;

        if (this.rafId === null) {
          this.lastTime = performance.now();
          this.animate();
        }
      }

      setPosition(position) {
        this.spring.x.position = position.x;
        this.spring.x.velocity = 0;
        this.spring.y.position = position.y;
        this.spring.y.velocity = 0;
      }

      getPosition() {
        return {
          x: this.spring.x.position,
          y: this.spring.y.position
        };
      }

      subscribe(callback) {
        this.onUpdate = callback;
        return () => { this.onUpdate = null; };
      }

      animate = () => {
        const now = performance.now();
        const dt = Math.min((now - this.lastTime) / 1000, 0.1);
        this.lastTime = now;

        // Animate X
        const [newX, newVx] = this.animateAxis(
          this.spring.x.position,
          this.spring.x.velocity,
          this.spring.x.target,
          dt
        );

        // Animate Y
        const [newY, newVy] = this.animateAxis(
          this.spring.y.position,
          this.spring.y.velocity,
          this.spring.y.target,
          dt
        );

        this.spring.x.position = newX;
        this.spring.x.velocity = newVx;
        this.spring.y.position = newY;
        this.spring.y.velocity = newVy;

        if (this.onUpdate) {
          this.onUpdate(this.getPosition());
        }

        // Check if at rest
        const xAtRest = this.isAtRest(this.spring.x.position, this.spring.x.velocity, this.spring.x.target);
        const yAtRest = this.isAtRest(this.spring.y.position, this.spring.y.velocity, this.spring.y.target);

        if (!xAtRest || !yAtRest) {
          this.rafId = requestAnimationFrame(this.animate);
        } else {
          this.spring.x.position = this.spring.x.target;
          this.spring.x.velocity = 0;
          this.spring.y.position = this.spring.y.target;
          this.spring.y.velocity = 0;

          if (this.onUpdate) {
            this.onUpdate(this.getPosition());
          }

          this.rafId = null;
        }
      };

      animateAxis(position, velocity, target, dt) {
        const { stiffness, damping, mass } = this.config;
        const springForce = -stiffness * (position - target);
        const dampingForce = -damping * velocity;
        const force = springForce + dampingForce;
        const acceleration = force / mass;
        const newVelocity = velocity + acceleration * dt;
        const newPosition = position + newVelocity * dt;
        return [newPosition, newVelocity];
      }

      isAtRest(position, velocity, target) {
        return Math.abs(position - target) < this.config.restDelta &&
               Math.abs(velocity) < this.config.restDelta;
      }

      destroy() {
        if (this.rafId !== null) {
          cancelAnimationFrame(this.rafId);
          this.rafId = null;
        }
        this.onUpdate = null;
      }
    }

    // Cursor component with animation
    function Cursor({ user, animated }) {
      if (!user.cursor) return null;

      const springRef = useRef(null);
      const [animatedPosition, setAnimatedPosition] = useState(user.cursor);

      // Initialize spring
      useEffect(() => {
        if (!animated || !user.cursor) return;

        const spring = new SpringAnimation();
        spring.setPosition(user.cursor);
        spring.subscribe((pos) => setAnimatedPosition(pos));
        springRef.current = spring;

        return () => {
          spring.destroy();
          springRef.current = null;
        };
      }, [animated, user.cursor]);

      // Update target
      useEffect(() => {
        if (animated && springRef.current && user.cursor) {
          springRef.current.setTarget(user.cursor);
        } else if (!animated && user.cursor) {
          setAnimatedPosition(user.cursor);
        }
      }, [user.cursor, animated]);

      const displayPosition = animated ? animatedPosition : user.cursor;

      return (
        <div
          data-cursor-id={user.id}
          style={{
            position: 'fixed',
            left: 0,
            top: 0,
            transform: `translate(${displayPosition.x}px, ${displayPosition.y}px)`,
            pointerEvents: 'none',
            zIndex: 9999,
            willChange: 'transform'
          }}
        >
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
               style={{ filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))' }}>
            <path d="M5 3L19 12L12 13L9 19L5 3Z"
                  fill={user.color}
                  stroke="white"
                  strokeWidth="1.5" />
          </svg>
          <div style={{
            position: 'absolute',
            left: '20px',
            top: '0px',
            backgroundColor: user.color,
            color: 'white',
            padding: '2px 8px',
            borderRadius: '4px',
            fontSize: '12px',
            fontWeight: 500,
            whiteSpace: 'nowrap',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
          }}>
            {user.name} {animated ? '(Animated)' : '(Instant)'}
          </div>
        </div>
      );
    }

    // Simulate remote users
    function useSimulatedRemoteUsers() {
      const [users, setUsers] = useState([]);

      useEffect(() => {
        const bc = new BroadcastChannel('synckit_cursors_animated');

        bc.onmessage = (event) => {
          if (event.data.type === 'CURSOR_UPDATE') {
            const { userId, cursor, name, color } = event.data;

            setUsers(prevUsers => {
              const existingIndex = prevUsers.findIndex(u => u.id === userId);
              const user = { id: userId, name, color, cursor };

              if (existingIndex >= 0) {
                const newUsers = [...prevUsers];
                newUsers[existingIndex] = user;
                return newUsers;
              } else {
                return [...prevUsers, user];
              }
            });
          }
        };

        return () => bc.close();
      }, []);

      return users;
    }

    function App() {
      const [localCursor, setLocalCursor] = useState(null);
      const [animated, setAnimated] = useState(true);
      const [userId] = useState(() => 'user_' + Math.random().toString(36).substr(2, 9));
      const [userName] = useState(() => 'Tab ' + (Math.floor(Math.random() * 10) + 1));
      const [userColor] = useState(() => {
        const hue = Math.floor(Math.random() * 360);
        return `hsl(${hue}, 70%, 50%)`;
      });

      const remoteUsers = useSimulatedRemoteUsers();

      const broadcastCursor = useCallback((cursor) => {
        const bc = new BroadcastChannel('synckit_cursors_animated');
        bc.postMessage({
          type: 'CURSOR_UPDATE',
          userId,
          cursor,
          name: userName,
          color: userColor
        });
        bc.close();
      }, [userId, userName, userColor]);

      const handleMouseMove = useCallback((e) => {
        const cursor = {
          x: Math.round(e.clientX),
          y: Math.round(e.clientY)
        };

        setLocalCursor(cursor);
        broadcastCursor(cursor);
      }, [broadcastCursor]);

      return (
        <div onMouseMove={handleMouseMove}>
          <div className="header">
            <h1>âœ¨ SyncKit Cursors - Smooth Animation Test</h1>
            <p>Phase 5: Spring physics animation for buttery smooth cursor movement</p>

            <div className="toggle-container">
              <label className="toggle-label">
                <input
                  type="checkbox"
                  checked={animated}
                  onChange={(e) => setAnimated(e.target.checked)}
                />
                <span>Enable smooth spring animation</span>
              </label>
              <p style={{ marginTop: '10px', fontSize: '14px', color: '#6b7280' }}>
                Toggle this to see the difference between instant vs smooth animated cursors
              </p>
            </div>

            <div className="status">
              <div className="status-ok">âœ“ Animation: {animated ? 'ON (Spring physics)' : 'OFF (Instant)'}</div>
              <div className="status-ok">âœ“ Spring config: damping=45, stiffness=400, mass=1</div>
              <div style={{ marginTop: '10px' }}>
                Your cursor: x={localCursor?.x || 0}, y={localCursor?.y || 0}
              </div>
              <div>
                Remote cursors: {remoteUsers.length}
              </div>
            </div>
          </div>

          <div className="instructions">
            <h3>How to test:</h3>
            <ol>
              <li>Open this file in <strong>two browser tabs</strong> side by side</li>
              <li>Move your mouse quickly in Tab A - watch how the cursor smoothly follows in Tab B</li>
              <li>Toggle animation OFF - notice cursors now jump instantly (no smoothness)</li>
              <li>Toggle animation ON - cursors now have buttery smooth spring physics</li>
              <li>Try circular motions and quick movements to feel the difference</li>
            </ol>
            <p style={{ marginTop: '10px', fontWeight: 500, color: '#0ea5e9' }}>
              ðŸ’¡ The spring animation makes cursors feel natural and professional, like Figma or Miro!
            </p>
          </div>

          <div className="workspace">
            <h2>Workspace Area</h2>
            <p>Move your mouse around quickly to see the smooth animation in action.</p>
            <p style={{ marginTop: '10px', color: '#6b7280' }}>
              With animation ON, cursors should glide smoothly. With animation OFF, they jump instantly.
            </p>
          </div>

          {/* Render remote cursors */}
          {remoteUsers.map(user => (
            <Cursor key={user.id} user={user} animated={animated} />
          ))}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
